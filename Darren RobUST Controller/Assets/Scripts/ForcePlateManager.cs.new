using UnityEngine;
using System;
using System.Threading;

/// <summary>
/// Manages data from the Vicon force plates using a dedicated thread
/// for deterministic sampling of ground reaction forces and center of pressure.
/// </summary>
public class ForcePlateManager : MonoBehaviour
{
    [Header("Connection Settings")]
    [Tooltip("Port of the Vicon DataStream server")]
    public int serverPort = 801;
    
    [Header("Sampling Settings")]
    [Tooltip("Target sampling rate in Hz")]
    public double samplingRate_Hz = 100.0;

    // Thread-related fields
    private Thread forcePlateThread;
    private volatile bool isRunning = false;
    
    // Thread-safe data storage with locking
    private readonly object dataLock = new object();
    private int forcePlateCount = 0;
    private ForcePlateData[] forcePlateDataArray;
    private Vector3[] worldCentersOfPressure;
    private Vector3[] localCentersOfPressure;
    private Vector3 globalCenterOfPressure;

    // Vicon SDK client
    private object viconClient;

    /// <summary>
    /// Initializes the force plate manager.
    /// Called by RobotController in the correct dependency order.
    /// </summary>
    /// <returns>True if initialization succeeded, false otherwise</returns>
    public bool Initialize()
    {
        // Load the Vicon assembly
        var assembly = System.Reflection.Assembly.Load("ViconDataStreamSDK_DotNET");
        if (assembly == null)
        {
            Debug.LogError("Failed to load ViconDataStreamSDK_DotNET assembly");
            return false;
        }
        
        // Create the client dynamically
        Type clientType = assembly.GetType("ViconDataStreamSDK.DotNET.Client");
        if (clientType == null)
        {
            Debug.LogError("Failed to find Client type in Vicon SDK assembly");
            return false;
        }
        
        viconClient = Activator.CreateInstance(clientType);
        
        // Connect to the Vicon DataStream server
        Debug.Log($"Connecting to Vicon DataStream on localhost:{serverPort}...");
        
        // Connect using reflection
        var connectMethod = clientType.GetMethod("Connect");
        var result = connectMethod.Invoke(viconClient, new object[] { $"localhost:{serverPort}" });
        
        // Check result
        var resultProperty = result.GetType().GetProperty("Result");
        object resultValue = resultProperty.GetValue(result);
        
        if (!resultValue.ToString().Equals("Success"))
        {
            Debug.LogError($"Failed to connect to Vicon DataStream: {resultValue}");
            return false;
        }
        
        // Enable the required data types
        clientType.GetMethod("EnableDeviceData").Invoke(viconClient, null);
        
        // Get the initial force plate count
        var fpCountResult = clientType.GetMethod("GetForcePlateCount").Invoke(viconClient, null);
        var fpCountProperty = fpCountResult.GetType().GetProperty("ForcePlateCount");
        forcePlateCount = Convert.ToInt32(fpCountProperty.GetValue(fpCountResult));
        
        if (forcePlateCount == 0)
        {
            Debug.LogError("No force plates detected in the Vicon system");
            return false;
        }
        
        Debug.Log($"Detected {forcePlateCount} force plates");
        
        // Pre-allocate data arrays
        forcePlateDataArray = new ForcePlateData[forcePlateCount];
        worldCentersOfPressure = new Vector3[forcePlateCount];
        localCentersOfPressure = new Vector3[forcePlateCount];
        
        // Start the sampling thread
        isRunning = true;
        forcePlateThread = new Thread(ForcePlateSamplingLoop);
        forcePlateThread.IsBackground = true;
        forcePlateThread.Start();
        
        Debug.Log($"ForcePlateManager initialized successfully. Sampling at {samplingRate_Hz} Hz.");
        return true;
    }
    
    /// <summary>
    /// High-frequency sampling loop running in dedicated background thread.
    /// </summary>
    private void ForcePlateSamplingLoop()
    {
        // Cache method info objects for better performance
        Type clientType = viconClient.GetType();
        var getFrameMethod = clientType.GetMethod("GetFrame");
        var getGlobalForceVectorMethod = clientType.GetMethod("GetGlobalForceVector");
        var getGlobalMomentVectorMethod = clientType.GetMethod("GetGlobalMomentVector");
        var getGlobalCentreOfPressureMethod = clientType.GetMethod("GetGlobalCentreOfPressure");
        var getLocalCentreOfPressureMethod = clientType.GetMethod("GetCentreOfPressure");
        
        // Precise timing using high-resolution Stopwatch
        double exactIntervalTicks = (double)System.Diagnostics.Stopwatch.Frequency / samplingRate_Hz;
        long targetIntervalTicks = (long)Math.Round(exactIntervalTicks);
        long nextTargetTime = System.Diagnostics.Stopwatch.GetTimestamp() + targetIntervalTicks;

        while (isRunning)
        {
            // Get a new frame from the Vicon DataStream
            var frameResult = getFrameMethod.Invoke(viconClient, null);
            var frameResultProperty = frameResult.GetType().GetProperty("Result");
            string frameResultValue = frameResultProperty.GetValue(frameResult).ToString();
            
            if (frameResultValue == "Success")
            {
                // Process each force plate
                Vector3[] forces = new Vector3[forcePlateCount];
                Vector3[] moments = new Vector3[forcePlateCount];
                Vector3[] worldCops = new Vector3[forcePlateCount];
                Vector3[] localCops = new Vector3[forcePlateCount];
                float totalVerticalForce = 0;
                
                for (uint i = 0; i < forcePlateCount; i++)
                {
                    // Get force in global coordinate system
                    var forceResult = getGlobalForceVectorMethod.Invoke(viconClient, new object[] { i });
                    var forceResultProperty = forceResult.GetType().GetProperty("Result");
                    string forceResultValue = forceResultProperty.GetValue(forceResult).ToString();
                    
                    if (forceResultValue == "Success")
                    {
                        var forceVectorProperty = forceResult.GetType().GetProperty("ForceVector");
                        double[] forceVector = (double[])forceVectorProperty.GetValue(forceResult);
                        
                        forces[i] = new Vector3(
                            (float)forceVector[0],
                            (float)forceVector[1],
                            (float)forceVector[2]
                        );
                        totalVerticalForce += forces[i].z; // Assuming Z is vertical in Vicon
                    }
                    
                    // Get moment in global coordinate system
                    var momentResult = getGlobalMomentVectorMethod.Invoke(viconClient, new object[] { i });
                    var momentResultProperty = momentResult.GetType().GetProperty("Result");
                    string momentResultValue = momentResultProperty.GetValue(momentResult).ToString();
                    
                    if (momentResultValue == "Success")
                    {
                        var momentVectorProperty = momentResult.GetType().GetProperty("MomentVector");
                        double[] momentVector = (double[])momentVectorProperty.GetValue(momentResult);
                        
                        moments[i] = new Vector3(
                            (float)momentVector[0],
                            (float)momentVector[1],
                            (float)momentVector[2]
                        );
                    }
                    
                    // Get world (global) center of pressure
                    var worldCopResult = getGlobalCentreOfPressureMethod.Invoke(viconClient, new object[] { i });
                    var worldCopResultProperty = worldCopResult.GetType().GetProperty("Result");
                    string worldCopResultValue = worldCopResultProperty.GetValue(worldCopResult).ToString();
                    
                    if (worldCopResultValue == "Success")
                    {
                        var worldCopVectorProperty = worldCopResult.GetType().GetProperty("CentreOfPressure");
                        double[] worldCopVector = (double[])worldCopVectorProperty.GetValue(worldCopResult);
                        
                        worldCops[i] = new Vector3(
                            (float)worldCopVector[0],
                            (float)worldCopVector[1],
                            (float)worldCopVector[2]
                        );
                    }
                    
                    // Get local center of pressure (in force plate coordinates)
                    var localCopResult = getLocalCentreOfPressureMethod.Invoke(viconClient, new object[] { i });
                    var localCopResultProperty = localCopResult.GetType().GetProperty("Result");
                    string localCopResultValue = localCopResultProperty.GetValue(localCopResult).ToString();
                    
                    if (localCopResultValue == "Success")
                    {
                        var localCopVectorProperty = localCopResult.GetType().GetProperty("CentreOfPressure");
                        double[] localCopVector = (double[])localCopVectorProperty.GetValue(localCopResult);
                        
                        localCops[i] = new Vector3(
                            (float)localCopVector[0],
                            (float)localCopVector[1],
                            (float)localCopVector[2]
                        );
                    }
                }
                
                // Calculate global center of pressure as weighted average based on vertical forces
                Vector3 global_cop = Vector3.zero;
                if (totalVerticalForce > 1.0f) // Only calculate if there's significant force
                {
                    for (int i = 0; i < forcePlateCount; i++)
                    {
                        float weight = forces[i].z / totalVerticalForce;
                        global_cop += worldCops[i] * weight;
                    }
                }
                
                // Update thread-safe data store with atomic operation
                lock (dataLock)
                {
                    for (int i = 0; i < forcePlateCount; i++)
                    {
                        forcePlateDataArray[i] = new ForcePlateData(forces[i], moments[i]);
                        worldCentersOfPressure[i] = worldCops[i];
                        localCentersOfPressure[i] = localCops[i];
                    }
                    globalCenterOfPressure = global_cop;
                }
            }
            
            // Precise timing control
            long currentTime = System.Diagnostics.Stopwatch.GetTimestamp();
            if (nextTargetTime > currentTime)
            {
                // Use SpinWait for sub-millisecond precision
                SpinWait.SpinUntil(() => System.Diagnostics.Stopwatch.GetTimestamp() >= nextTargetTime);
            }

            // Advance to next target time with drift compensation
            nextTargetTime += targetIntervalTicks;
            currentTime = System.Diagnostics.Stopwatch.GetTimestamp();
            if (nextTargetTime <= currentTime)
            {
                nextTargetTime = currentTime + targetIntervalTicks;
            }
        }
    }

    /// <summary>
    /// Gets the force plate data for a specific plate.
    /// Thread-safe access.
    /// </summary>
    public ForcePlateData GetForcePlateData(int plateIndex = 0)
    {
        if (plateIndex < 0 || plateIndex >= forcePlateCount)
        {
            Debug.LogWarning($"Requested invalid force plate index {plateIndex}");
            return new ForcePlateData(Vector3.zero, Vector3.zero);
        }
        
        lock (dataLock)
        {
            return new ForcePlateData(
                forcePlateDataArray[plateIndex].Force, 
                forcePlateDataArray[plateIndex].Moment
            );
        }
    }
    
    /// <summary>
    /// Gets a copy of the force plate data array for all plates.
    /// Thread-safe access.
    /// </summary>
    public ForcePlateData[] GetAllForcePlateData()
    {
        ForcePlateData[] result = new ForcePlateData[forcePlateCount];
        lock (dataLock)
        {
            for (int i = 0; i < forcePlateCount; i++)
            {
                result[i] = new ForcePlateData(
                    forcePlateDataArray[i].Force,
                    forcePlateDataArray[i].Moment
                );
            }
        }
        return result;
    }
    
    /// <summary>
    /// Gets the center of pressure for a specific force plate.
    /// Thread-safe access.
    /// </summary>
    public Vector3 GetCenterOfPressure(int plateIndex = 0, bool useLocalCoordinates = false)
    {
        if (plateIndex < 0 || plateIndex >= forcePlateCount)
        {
            Debug.LogWarning($"Requested invalid force plate index {plateIndex}");
            return Vector3.zero;
        }
        
        lock (dataLock)
        {
            return useLocalCoordinates ? localCentersOfPressure[plateIndex] : worldCentersOfPressure[plateIndex];
        }
    }
    
    /// <summary>
    /// Gets the global center of pressure across all force plates.
    /// Thread-safe access.
    /// </summary>
    public Vector3 GetGlobalCenterOfPressure()
    {
        lock (dataLock)
        {
            return globalCenterOfPressure;
        }
    }
    
    /// <summary>
    /// Gets the number of force plates available.
    /// </summary>
    public int GetForcePlateCount()
    {
        return forcePlateCount;
    }

    /// <summary>
    /// Clean up resources on application quit
    /// </summary>
    private void OnDestroy()
    {
        isRunning = false;
        if (forcePlateThread != null && forcePlateThread.IsAlive)
        {
            forcePlateThread.Join(500); // Wait up to 500ms for clean exit
        }
        
        if (viconClient != null)
        {
            try
            {
                // Disconnect using reflection
                var disconnectMethod = viconClient.GetType().GetMethod("Disconnect");
                disconnectMethod.Invoke(viconClient, null);
            }
            catch (Exception e)
            {
                Debug.LogWarning($"Error disconnecting from Vicon: {e.Message}");
            }
        }
    }
}